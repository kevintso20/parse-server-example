"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[817],{17706:(e,n,t)=>{t.d(n,{C:()=>i,P:()=>s,R:()=>a});var r=Object.defineProperty,o=(e,n)=>r(e,"name",{value:n,configurable:!0});class i{constructor(e){this.getStartOfToken=()=>this._start,this.getCurrentPosition=()=>this._pos,this.eol=()=>this._sourceText.length===this._pos,this.sol=()=>0===this._pos,this.peek=()=>this._sourceText.charAt(this._pos)?this._sourceText.charAt(this._pos):null,this.next=()=>{const e=this._sourceText.charAt(this._pos);return this._pos++,e},this.eat=e=>{if(this._testNextCharacter(e))return this._start=this._pos,this._pos++,this._sourceText.charAt(this._pos-1)},this.eatWhile=e=>{let n=this._testNextCharacter(e),t=!1;for(n&&(t=n,this._start=this._pos);n;)this._pos++,n=this._testNextCharacter(e),t=!0;return t},this.eatSpace=()=>this.eatWhile(/[\s\u00a0]/),this.skipToEnd=()=>{this._pos=this._sourceText.length},this.skipTo=e=>{this._pos=e},this.match=(e,n=!0,t=!1)=>{let r=null,o=null;return"string"==typeof e?(o=new RegExp(e,t?"i":"g").test(this._sourceText.substr(this._pos,e.length)),r=e):e instanceof RegExp&&(o=this._sourceText.slice(this._pos).match(e),r=null==o?void 0:o[0]),!(null==o||!("string"==typeof e||o instanceof Array&&this._sourceText.startsWith(o[0],this._pos)))&&(n&&(this._start=this._pos,r&&r.length&&(this._pos+=r.length)),o)},this.backUp=e=>{this._pos-=e},this.column=()=>this._pos,this.indentation=()=>{const e=this._sourceText.match(/\s*/);let n=0;if(e&&0!==e.length){const t=e[0];let r=0;for(;t.length>r;)9===t.charCodeAt(r)?n+=2:n++,r++}return n},this.current=()=>this._sourceText.slice(this._start,this._pos),this._start=0,this._pos=0,this._sourceText=e}_testNextCharacter(e){const n=this._sourceText.charAt(this._pos);let t=!1;return t="string"==typeof e?n===e:e instanceof RegExp?e.test(n):e(n),t}}o(i,"CharacterStream");class a{constructor(e,n){this.containsPosition=e=>this.start.line===e.line?this.start.character<=e.character:this.end.line===e.line?this.end.character>=e.character:this.start.line<=e.line&&this.end.line>=e.line,this.start=e,this.end=n}setStart(e,n){this.start=new s(e,n)}setEnd(e,n){this.end=new s(e,n)}}o(a,"Range");class s{constructor(e,n){this.lessThanOrEqualTo=e=>this.line<e.line||this.line===e.line&&this.character<=e.character,this.line=e,this.character=n}setLine(e){this.line=e}setCharacter(e){this.character=e}}o(s,"Position")},29817:(e,n,t)=>{t.r(n);var r=t(96539),o=t(16011);function i(e){var n,t,r;const i=e.getSchema(),a=null!==(n=null!==(t=null!==(r=null==i?void 0:i.astNode)&&void 0!==r?r:null==i?void 0:i.getQueryType())&&void 0!==t?t:null==i?void 0:i.getMutationType())&&void 0!==n?n:null==i?void 0:i.getSubscriptionType();let s=0;return{SchemaDefinition(n){a?e.reportError(new o.__("Cannot define a new schema within a schema extension.",{nodes:n})):(s>0&&e.reportError(new o.__("Must provide only one schema definition.",{nodes:n})),++s)}}}function a(e){const n=e.getSchema(),t=Object.create(null),r=n?{query:n.getQueryType(),mutation:n.getMutationType(),subscription:n.getSubscriptionType()}:{};return{SchemaDefinition:i,SchemaExtension:i};function i(n){var i;const a=null!==(i=n.operationTypes)&&void 0!==i?i:[];for(const n of a){const i=n.operation,a=t[i];r[i]?e.reportError(new o.__(`Type for ${i} already defined in the schema. It cannot be redefined.`,{nodes:n})):a?e.reportError(new o.__(`There can be only one ${i} type in schema.`,{nodes:[a,n]})):t[i]=n}return!1}}function s(e){const n=Object.create(null),t=e.getSchema();return{ScalarTypeDefinition:r,ObjectTypeDefinition:r,InterfaceTypeDefinition:r,UnionTypeDefinition:r,EnumTypeDefinition:r,InputObjectTypeDefinition:r};function r(r){const i=r.name.value;if(null==t||!t.getType(i))return n[i]?e.reportError(new o.__(`There can be only one type named "${i}".`,{nodes:[n[i],r.name]})):n[i]=r.name,!1;e.reportError(new o.__(`Type "${i}" already exists in the schema. It cannot also be defined in this type definition.`,{nodes:r.name}))}}var c=t(89130);function u(e){const n=e.getSchema(),t=n?n.getTypeMap():Object.create(null),r=Object.create(null);return{EnumTypeDefinition:i,EnumTypeExtension:i};function i(n){var i;const a=n.name.value;r[a]||(r[a]=Object.create(null));const s=null!==(i=n.values)&&void 0!==i?i:[],u=r[a];for(const n of s){const r=n.name.value,i=t[a];(0,c.EM)(i)&&i.getValue(r)?e.reportError(new o.__(`Enum value "${a}.${r}" already exists in the schema. It cannot also be defined in this type extension.`,{nodes:n.name})):u[r]?e.reportError(new o.__(`Enum value "${a}.${r}" can only be defined once.`,{nodes:[u[r],n.name]})):u[r]=n.name}return!1}}function l(e){const n=e.getSchema(),t=n?n.getTypeMap():Object.create(null),r=Object.create(null);return{InputObjectTypeDefinition:i,InputObjectTypeExtension:i,InterfaceTypeDefinition:i,InterfaceTypeExtension:i,ObjectTypeDefinition:i,ObjectTypeExtension:i};function i(n){var i;const a=n.name.value;r[a]||(r[a]=Object.create(null));const s=null!==(i=n.fields)&&void 0!==i?i:[],c=r[a];for(const n of s){const r=n.name.value;f(t[a],r)?e.reportError(new o.__(`Field "${a}.${r}" already exists in the schema. It cannot also be defined in this type extension.`,{nodes:n.name})):c[r]?e.reportError(new o.__(`Field "${a}.${r}" can only be defined once.`,{nodes:[c[r],n.name]})):c[r]=n.name}return!1}}function f(e,n){return!!((0,c.lp)(e)||(0,c.oT)(e)||(0,c.hL)(e))&&null!=e.getFields()[n]}function d(e){const n=Object.create(null),t=e.getSchema();return{DirectiveDefinition(r){const i=r.name.value;if(null==t||!t.getDirective(i))return n[i]?e.reportError(new o.__(`There can be only one directive named "@${i}".`,{nodes:[n[i],r.name]})):n[i]=r.name,!1;e.reportError(new o.__(`Directive "@${i}" already exists in the schema. It cannot be redefined.`,{nodes:r.name}))}}}var p=t(49299),h=t(7483),E=t(57554);function _(e){return e.kind===E.h.OPERATION_DEFINITION||e.kind===E.h.FRAGMENT_DEFINITION}function m(e){return e.kind===E.h.SCALAR_TYPE_DEFINITION||e.kind===E.h.OBJECT_TYPE_DEFINITION||e.kind===E.h.INTERFACE_TYPE_DEFINITION||e.kind===E.h.UNION_TYPE_DEFINITION||e.kind===E.h.ENUM_TYPE_DEFINITION||e.kind===E.h.INPUT_OBJECT_TYPE_DEFINITION}function T(e){return e.kind===E.h.SCALAR_TYPE_EXTENSION||e.kind===E.h.OBJECT_TYPE_EXTENSION||e.kind===E.h.INTERFACE_TYPE_EXTENSION||e.kind===E.h.UNION_TYPE_EXTENSION||e.kind===E.h.ENUM_TYPE_EXTENSION||e.kind===E.h.INPUT_OBJECT_TYPE_EXTENSION}var v=t(82299);function g(e){const n=e.getSchema(),t=n?n.getTypeMap():Object.create(null),r=Object.create(null);for(const n of e.getDocument().definitions)m(n)&&(r[n.name.value]=!0);const i=[...Object.keys(t),...Object.keys(r)];return{NamedType(n,a,s,c,u){const l=n.name.value;if(!t[l]&&!r[l]){var f;const t=null!==(f=u[2])&&void 0!==f?f:s,r=null!=t&&"kind"in(d=t)&&(function(e){return e.kind===E.h.SCHEMA_DEFINITION||m(e)||e.kind===E.h.DIRECTIVE_DEFINITION}(d)||function(e){return e.kind===E.h.SCHEMA_EXTENSION||T(e)}(d));if(r&&I.includes(l))return;const a=(0,h.D)(l,r?I.concat(i):i);e.reportError(new o.__(`Unknown type "${l}".`+(0,p.l)(a),{nodes:n}))}var d}}}const I=[...t(62697).HS,...v.nL].map((e=>e.name));var N=t(57493),y=t(87021),O=t(35239),b=t(65916),S=t(73798);function D(e){const n=Object.create(null),t=e.getSchema(),r=t?t.getDirectives():S.V4;for(const e of r)n[e.name]=e.locations;const i=e.getDocument().definitions;for(const e of i)e.kind===E.h.DIRECTIVE_DEFINITION&&(n[e.name.value]=e.locations.map((e=>e.value)));return{Directive(t,r,i,a,s){const c=t.name.value,u=n[c];if(!u)return void e.reportError(new o.__(`Unknown directive "@${c}".`,{nodes:t}));const l=function(e){const n=e[e.length-1];switch("kind"in n||(0,y.k)(!1),n.kind){case E.h.OPERATION_DEFINITION:return function(e){switch(e){case O.ku.QUERY:return b.B.QUERY;case O.ku.MUTATION:return b.B.MUTATION;case O.ku.SUBSCRIPTION:return b.B.SUBSCRIPTION}}(n.operation);case E.h.FIELD:return b.B.FIELD;case E.h.FRAGMENT_SPREAD:return b.B.FRAGMENT_SPREAD;case E.h.INLINE_FRAGMENT:return b.B.INLINE_FRAGMENT;case E.h.FRAGMENT_DEFINITION:return b.B.FRAGMENT_DEFINITION;case E.h.VARIABLE_DEFINITION:return b.B.VARIABLE_DEFINITION;case E.h.SCHEMA_DEFINITION:case E.h.SCHEMA_EXTENSION:return b.B.SCHEMA;case E.h.SCALAR_TYPE_DEFINITION:case E.h.SCALAR_TYPE_EXTENSION:return b.B.SCALAR;case E.h.OBJECT_TYPE_DEFINITION:case E.h.OBJECT_TYPE_EXTENSION:return b.B.OBJECT;case E.h.FIELD_DEFINITION:return b.B.FIELD_DEFINITION;case E.h.INTERFACE_TYPE_DEFINITION:case E.h.INTERFACE_TYPE_EXTENSION:return b.B.INTERFACE;case E.h.UNION_TYPE_DEFINITION:case E.h.UNION_TYPE_EXTENSION:return b.B.UNION;case E.h.ENUM_TYPE_DEFINITION:case E.h.ENUM_TYPE_EXTENSION:return b.B.ENUM;case E.h.ENUM_VALUE_DEFINITION:return b.B.ENUM_VALUE;case E.h.INPUT_OBJECT_TYPE_DEFINITION:case E.h.INPUT_OBJECT_TYPE_EXTENSION:return b.B.INPUT_OBJECT;case E.h.INPUT_VALUE_DEFINITION:{const n=e[e.length-3];return"kind"in n||(0,y.k)(!1),n.kind===E.h.INPUT_OBJECT_TYPE_DEFINITION?b.B.INPUT_FIELD_DEFINITION:b.B.ARGUMENT_DEFINITION}default:(0,y.k)(!1,"Unexpected kind: "+(0,N.X)(n.kind))}}(s);l&&!u.includes(l)&&e.reportError(new o.__(`Directive "@${c}" may not be used on ${l}.`,{nodes:t}))}}}function F(e){const n=Object.create(null),t=e.getSchema(),r=t?t.getDirectives():S.V4;for(const e of r)n[e.name]=!e.isRepeatable;const i=e.getDocument().definitions;for(const e of i)e.kind===E.h.DIRECTIVE_DEFINITION&&(n[e.name.value]=!e.repeatable);const a=Object.create(null),s=Object.create(null);return{enter(t){if(!("directives"in t)||!t.directives)return;let r;if(t.kind===E.h.SCHEMA_DEFINITION||t.kind===E.h.SCHEMA_EXTENSION)r=a;else if(m(t)||T(t)){const e=t.name.value;r=s[e],void 0===r&&(s[e]=r=Object.create(null))}else r=Object.create(null);for(const i of t.directives){const t=i.name.value;n[t]&&(r[t]?e.reportError(new o.__(`The directive "@${t}" can only be used once at this location.`,{nodes:[r[t],i]})):r[t]=i)}}}}function $(e){const n=e.getSchema(),t=Object.create(null);for(const n of e.getDocument().definitions)m(n)&&(t[n.name.value]=n);return{ScalarTypeExtension:r,ObjectTypeExtension:r,InterfaceTypeExtension:r,UnionTypeExtension:r,EnumTypeExtension:r,InputObjectTypeExtension:r};function r(r){const i=r.name.value,a=t[i],s=null==n?void 0:n.getType(i);let u;if(a?u=w[a.kind]:s&&(l=s,u=(0,c.KA)(l)?E.h.SCALAR_TYPE_EXTENSION:(0,c.lp)(l)?E.h.OBJECT_TYPE_EXTENSION:(0,c.oT)(l)?E.h.INTERFACE_TYPE_EXTENSION:(0,c.EN)(l)?E.h.UNION_TYPE_EXTENSION:(0,c.EM)(l)?E.h.ENUM_TYPE_EXTENSION:(0,c.hL)(l)?E.h.INPUT_OBJECT_TYPE_EXTENSION:void(0,y.k)(!1,"Unexpected type: "+(0,N.X)(l))),u){if(u!==r.kind){const n=function(e){switch(e){case E.h.SCALAR_TYPE_EXTENSION:return"scalar";case E.h.OBJECT_TYPE_EXTENSION:return"object";case E.h.INTERFACE_TYPE_EXTENSION:return"interface";case E.h.UNION_TYPE_EXTENSION:return"union";case E.h.ENUM_TYPE_EXTENSION:return"enum";case E.h.INPUT_OBJECT_TYPE_EXTENSION:return"input object";default:(0,y.k)(!1,"Unexpected kind: "+(0,N.X)(e))}}(r.kind);e.reportError(new o.__(`Cannot extend non-${n} type "${i}".`,{nodes:a?[a,r]:r}))}}else{const a=Object.keys({...t,...null==n?void 0:n.getTypeMap()}),s=(0,h.D)(i,a);e.reportError(new o.__(`Cannot extend type "${i}" because it is not defined.`+(0,p.l)(s),{nodes:r.name}))}var l}}const w={[E.h.SCALAR_TYPE_DEFINITION]:E.h.SCALAR_TYPE_EXTENSION,[E.h.OBJECT_TYPE_DEFINITION]:E.h.OBJECT_TYPE_EXTENSION,[E.h.INTERFACE_TYPE_DEFINITION]:E.h.INTERFACE_TYPE_EXTENSION,[E.h.UNION_TYPE_DEFINITION]:E.h.UNION_TYPE_EXTENSION,[E.h.ENUM_TYPE_DEFINITION]:E.h.ENUM_TYPE_EXTENSION,[E.h.INPUT_OBJECT_TYPE_DEFINITION]:E.h.INPUT_OBJECT_TYPE_EXTENSION};function P(e,n){const t=new Map;for(const r of e){const e=n(r),o=t.get(e);void 0===o?t.set(e,[r]):o.push(r)}return t}function A(e){return{Field:n,Directive:n};function n(n){var t;const r=P(null!==(t=n.arguments)&&void 0!==t?t:[],(e=>e.name.value));for(const[n,t]of r)t.length>1&&e.reportError(new o.__(`There can be only one argument named "${n}".`,{nodes:t.map((e=>e.name))}))}}function C(e){const n=[];let t=Object.create(null);return{ObjectValue:{enter(){n.push(t),t=Object.create(null)},leave(){const e=n.pop();e||(0,y.k)(!1),t=e}},ObjectField(n){const r=n.name.value;t[r]?e.reportError(new o.__(`There can be only one input field named "${r}".`,{nodes:[t[r],n.name]})):t[r]=n.name}}}function k(e){return{Document(n){for(const t of n.definitions)if(!_(t)){const n=t.kind===E.h.SCHEMA_DEFINITION||t.kind===E.h.SCHEMA_EXTENSION?"schema":'"'+t.name.value+'"';e.reportError(new o.__(`The ${n} definition is not executable.`,{nodes:t}))}return!1}}}var R=t(81403),j=t(54785),U=t(39842);function x(e){const n=Object.create(null),t=e.getSchema(),r=t?t.getDirectives():S.V4;for(const e of r)n[e.name]=e.args.map((e=>e.name));const i=e.getDocument().definitions;for(const e of i)if(e.kind===E.h.DIRECTIVE_DEFINITION){var a;const t=null!==(a=e.arguments)&&void 0!==a?a:[];n[e.name.value]=t.map((e=>e.name.value))}return{Directive(t){const r=t.name.value,i=n[r];if(t.arguments&&i)for(const n of t.arguments){const t=n.name.value;if(!i.includes(t)){const a=(0,h.D)(t,i);e.reportError(new o.__(`Unknown argument "${t}" on directive "@${r}".`+(0,p.l)(a),{nodes:n}))}}return!1}}}function V(e){return{FragmentSpread(n){const t=n.name.value;e.getFragment(t)||e.reportError(new o.__(`Unknown fragment "${t}".`,{nodes:n.name}))}}}function M(e){const n=[],t=[];return{OperationDefinition:e=>(n.push(e),!1),FragmentDefinition:e=>(t.push(e),!1),Document:{leave(){const r=Object.create(null);for(const t of n)for(const n of e.getRecursivelyReferencedFragments(t))r[n.name.value]=!0;for(const n of t){const t=n.name.value;!0!==r[t]&&e.reportError(new o.__(`Fragment "${t}" is never used.`,{nodes:n}))}}}}}function X(e){switch(e.kind){case E.h.OBJECT:return{...e,fields:(n=e.fields,n.map((e=>({...e,value:X(e.value)}))).sort(((e,n)=>(0,R.K)(e.name.value,n.name.value))))};case E.h.LIST:return{...e,values:e.values.map(X)};case E.h.INT:case E.h.FLOAT:case E.h.STRING:case E.h.BOOLEAN:case E.h.NULL:case E.h.ENUM:case E.h.VARIABLE:return e}var n}function L(e){return Array.isArray(e)?e.map((([e,n])=>`subfields "${e}" conflict because `+L(n))).join(" and "):e}function Y(e,n,t,r,o,i,a){const s=e.getFragment(a);if(!s)return;const[c,u]=q(e,t,s);if(i!==c){G(e,n,t,r,o,i,c);for(const s of u)r.has(s,a,o)||(r.add(s,a,o),Y(e,n,t,r,o,i,s))}}function B(e,n,t,r,o,i,a){if(i===a)return;if(r.has(i,a,o))return;r.add(i,a,o);const s=e.getFragment(i),c=e.getFragment(a);if(!s||!c)return;const[u,l]=q(e,t,s),[f,d]=q(e,t,c);G(e,n,t,r,o,u,f);for(const a of d)B(e,n,t,r,o,i,a);for(const i of l)B(e,n,t,r,o,i,a)}function G(e,n,t,r,o,i,a){for(const[s,c]of Object.entries(i)){const i=a[s];if(i)for(const a of c)for(const c of i){const i=J(e,t,r,o,s,a,c);i&&n.push(i)}}}function J(e,n,t,r,o,i,a){const[s,u,l]=i,[f,d,p]=a,h=r||s!==f&&(0,c.lp)(s)&&(0,c.lp)(f);if(!h){const e=u.name.value,n=d.name.value;if(e!==n)return[[o,`"${e}" and "${n}" are different fields`],[u],[d]];if(H(u)!==H(d))return[[o,"they have differing arguments"],[u],[d]]}const E=null==l?void 0:l.type,_=null==p?void 0:p.type;if(E&&_&&z(E,_))return[[o,`they return conflicting types "${(0,N.X)(E)}" and "${(0,N.X)(_)}"`],[u],[d]];const m=u.selectionSet,T=d.selectionSet;if(m&&T){const r=function(e,n,t,r,o,i,a,s){const c=[],[u,l]=Q(e,n,o,i),[f,d]=Q(e,n,a,s);G(e,c,n,t,r,u,f);for(const o of d)Y(e,c,n,t,r,u,o);for(const o of l)Y(e,c,n,t,r,f,o);for(const o of l)for(const i of d)B(e,c,n,t,r,o,i);return c}(e,n,t,h,(0,c.xC)(E),m,(0,c.xC)(_),T);return function(e,n,t,r){if(e.length>0)return[[n,e.map((([e])=>e))],[t,...e.map((([,e])=>e)).flat()],[r,...e.map((([,,e])=>e)).flat()]]}(r,o,u,d)}}function H(e){var n;const t=null!==(n=e.arguments)&&void 0!==n?n:[],r={kind:E.h.OBJECT,fields:t.map((e=>({kind:E.h.OBJECT_FIELD,name:e.name,value:e.value})))};return(0,j.S)(X(r))}function z(e,n){return(0,c.HG)(e)?!(0,c.HG)(n)||z(e.ofType,n.ofType):!!(0,c.HG)(n)||((0,c.zM)(e)?!(0,c.zM)(n)||z(e.ofType,n.ofType):!!(0,c.zM)(n)||!(!(0,c.UT)(e)&&!(0,c.UT)(n))&&e!==n)}function Q(e,n,t,r){const o=n.get(r);if(o)return o;const i=Object.create(null),a=Object.create(null);W(e,t,r,i,a);const s=[i,Object.keys(a)];return n.set(r,s),s}function q(e,n,t){const r=n.get(t.selectionSet);if(r)return r;const o=(0,U._)(e.getSchema(),t.typeCondition);return Q(e,n,o,t.selectionSet)}function W(e,n,t,r,o){for(const i of t.selections)switch(i.kind){case E.h.FIELD:{const e=i.name.value;let t;((0,c.lp)(n)||(0,c.oT)(n))&&(t=n.getFields()[e]);const o=i.alias?i.alias.value:e;r[o]||(r[o]=[]),r[o].push([n,i,t]);break}case E.h.FRAGMENT_SPREAD:o[i.name.value]=!0;break;case E.h.INLINE_FRAGMENT:{const t=i.typeCondition,a=t?(0,U._)(e.getSchema(),t):n;W(e,a,i.selectionSet,r,o);break}}}class K{constructor(){this._data=new Map}has(e,n,t){var r;const[o,i]=e<n?[e,n]:[n,e],a=null===(r=this._data.get(o))||void 0===r?void 0:r.get(i);return void 0!==a&&(!!t||t===a)}add(e,n,t){const[r,o]=e<n?[e,n]:[n,e],i=this._data.get(r);void 0===i?this._data.set(r,new Map([[o,t]])):i.set(o,t)}}var Z=t(63459),ee=t(6981);function ne(e){var n;const t=Object.create(null),r=e.getSchema(),i=null!==(n=null==r?void 0:r.getDirectives())&&void 0!==n?n:S.V4;for(const e of i)t[e.name]=(0,ee.P)(e.args.filter(c.dK),(e=>e.name));const a=e.getDocument().definitions;for(const e of a)if(e.kind===E.h.DIRECTIVE_DEFINITION){var s;const n=null!==(s=e.arguments)&&void 0!==s?s:[];t[e.name.value]=(0,ee.P)(n.filter(te),(e=>e.name.value))}return{Directive:{leave(n){const r=n.name.value,i=t[r];if(i){var a;const t=null!==(a=n.arguments)&&void 0!==a?a:[],s=new Set(t.map((e=>e.name.value)));for(const[t,a]of Object.entries(i))if(!s.has(t)){const i=(0,c.P9)(a.type)?(0,N.X)(a.type):(0,j.S)(a.type);e.reportError(new o.__(`Directive "@${r}" argument "${t}" of type "${i}" is required, but it was not provided.`,{nodes:n}))}}}}}}function te(e){return e.type.kind===E.h.NON_NULL_TYPE&&null==e.defaultValue}var re=t(83178);function oe(e,n,t){var r;const i=null===(r=n.directives)||void 0===r?void 0:r.find((n=>n.name.value===e.name));if(i)return function(e,n,t){var r;const i={},a=null!==(r=n.arguments)&&void 0!==r?r:[],s=(0,ee.P)(a,(e=>e.name.value));for(const r of e.args){const e=r.name,a=r.type,f=s[e];if(!f){if(void 0!==r.defaultValue)i[e]=r.defaultValue;else if((0,c.zM)(a))throw new o.__(`Argument "${e}" of required type "${(0,N.X)(a)}" was not provided.`,{nodes:n});continue}const d=f.value;let p=d.kind===E.h.NULL;if(d.kind===E.h.VARIABLE){const n=d.name.value;if(null==t||(u=t,l=n,!Object.prototype.hasOwnProperty.call(u,l))){if(void 0!==r.defaultValue)i[e]=r.defaultValue;else if((0,c.zM)(a))throw new o.__(`Argument "${e}" of required type "${(0,N.X)(a)}" was provided the variable "$${n}" which was not provided a runtime value.`,{nodes:d});continue}p=null==t[n]}if(p&&(0,c.zM)(a))throw new o.__(`Argument "${e}" of non-null type "${(0,N.X)(a)}" must not be null.`,{nodes:d});const h=(0,re.u)(d,a,t);if(void 0===h)throw new o.__(`Argument "${e}" has invalid value ${(0,j.S)(d)}.`,{nodes:d});i[e]=h}var u,l;return i}(e,i,t)}function ie(e,n,t,r,o,i,a){for(const c of o.selections)switch(c.kind){case E.h.FIELD:{if(!ae(t,c))continue;const e=(s=c).alias?s.alias.value:s.name.value,n=i.get(e);void 0!==n?n.push(c):i.set(e,[c]);break}case E.h.INLINE_FRAGMENT:if(!ae(t,c)||!se(e,c,r))continue;ie(e,n,t,r,c.selectionSet,i,a);break;case E.h.FRAGMENT_SPREAD:{const o=c.name.value;if(a.has(o)||!ae(t,c))continue;a.add(o);const s=n[o];if(!s||!se(e,s,r))continue;ie(e,n,t,r,s.selectionSet,i,a);break}}var s}function ae(e,n){const t=oe(S.QE,n,e);if(!0===(null==t?void 0:t.if))return!1;const r=oe(S.Yf,n,e);return!1!==(null==r?void 0:r.if)}function se(e,n,t){const r=n.typeCondition;if(!r)return!0;const o=(0,U._)(e,r);return o===t||!!(0,c.m0)(o)&&e.isSubType(o,t)}function ce(e,n){const t=e.getInputType();if(!t)return;const r=(0,c.xC)(t);if((0,c.UT)(r))try{if(void 0===r.parseLiteral(n,void 0)){const r=(0,N.X)(t);e.reportError(new o.__(`Expected value of type "${r}", found ${(0,j.S)(n)}.`,{nodes:n}))}}catch(r){const i=(0,N.X)(t);r instanceof o.__?e.reportError(r):e.reportError(new o.__(`Expected value of type "${i}", found ${(0,j.S)(n)}; `+r.message,{nodes:n,originalError:r}))}else{const r=(0,N.X)(t);e.reportError(new o.__(`Expected value of type "${r}", found ${(0,j.S)(n)}.`,{nodes:n}))}}function ue(e,n,t,r,o){if((0,c.zM)(r)&&!(0,c.zM)(n)){if((null==t||t.kind===E.h.NULL)&&void 0===o)return!1;const i=r.ofType;return(0,Z.uJ)(e,n,i)}return(0,Z.uJ)(e,n,r)}const le=Object.freeze([k,function(e){const n=Object.create(null);return{OperationDefinition(t){const r=t.name;return r&&(n[r.value]?e.reportError(new o.__(`There can be only one operation named "${r.value}".`,{nodes:[n[r.value],r]})):n[r.value]=r),!1},FragmentDefinition:()=>!1}},function(e){let n=0;return{Document(e){n=e.definitions.filter((e=>e.kind===E.h.OPERATION_DEFINITION)).length},OperationDefinition(t){!t.name&&n>1&&e.reportError(new o.__("This anonymous operation must be the only defined operation.",{nodes:t}))}}},function(e){return{OperationDefinition(n){if("subscription"===n.operation){const t=e.getSchema(),r=t.getSubscriptionType();if(r){const i=n.name?n.name.value:null,a=Object.create(null),s=e.getDocument(),c=Object.create(null);for(const e of s.definitions)e.kind===E.h.FRAGMENT_DEFINITION&&(c[e.name.value]=e);const u=function(e,n,t,r,o){const i=new Map;return ie(e,n,t,r,o,i,new Set),i}(t,c,a,r,n.selectionSet);if(u.size>1){const n=[...u.values()].slice(1).flat();e.reportError(new o.__(null!=i?`Subscription "${i}" must select only one top level field.`:"Anonymous Subscription must select only one top level field.",{nodes:n}))}for(const n of u.values())n[0].name.value.startsWith("__")&&e.reportError(new o.__(null!=i?`Subscription "${i}" must not select an introspection top level field.`:"Anonymous Subscription must not select an introspection top level field.",{nodes:n}))}}}}},g,function(e){return{InlineFragment(n){const t=n.typeCondition;if(t){const n=(0,U._)(e.getSchema(),t);if(n&&!(0,c.Gv)(n)){const n=(0,j.S)(t);e.reportError(new o.__(`Fragment cannot condition on non composite type "${n}".`,{nodes:t}))}}},FragmentDefinition(n){const t=(0,U._)(e.getSchema(),n.typeCondition);if(t&&!(0,c.Gv)(t)){const t=(0,j.S)(n.typeCondition);e.reportError(new o.__(`Fragment "${n.name.value}" cannot condition on non composite type "${t}".`,{nodes:n.typeCondition}))}}}},function(e){return{VariableDefinition(n){const t=(0,U._)(e.getSchema(),n.type);if(void 0!==t&&!(0,c.j$)(t)){const t=n.variable.name.value,r=(0,j.S)(n.type);e.reportError(new o.__(`Variable "$${t}" cannot be non-input type "${r}".`,{nodes:n.type}))}}}},function(e){return{Field(n){const t=e.getType(),r=n.selectionSet;if(t)if((0,c.UT)((0,c.xC)(t))){if(r){const i=n.name.value,a=(0,N.X)(t);e.reportError(new o.__(`Field "${i}" must not have a selection since type "${a}" has no subfields.`,{nodes:r}))}}else if(!r){const r=n.name.value,i=(0,N.X)(t);e.reportError(new o.__(`Field "${r}" of type "${i}" must have a selection of subfields. Did you mean "${r} { ... }"?`,{nodes:n}))}}}},function(e){return{Field(n){const t=e.getParentType();if(t&&!e.getFieldDef()){const r=e.getSchema(),i=n.name.value;let a=(0,p.l)("to use an inline fragment on",function(e,n,t){if(!(0,c.m0)(n))return[];const r=new Set,o=Object.create(null);for(const a of e.getPossibleTypes(n))if(a.getFields()[t]){r.add(a),o[a.name]=1;for(const e of a.getInterfaces()){var i;e.getFields()[t]&&(r.add(e),o[e.name]=(null!==(i=o[e.name])&&void 0!==i?i:0)+1)}}return[...r].sort(((n,t)=>{const r=o[t.name]-o[n.name];return 0!==r?r:(0,c.oT)(n)&&e.isSubType(n,t)?-1:(0,c.oT)(t)&&e.isSubType(t,n)?1:(0,R.K)(n.name,t.name)})).map((e=>e.name))}(r,t,i));""===a&&(a=(0,p.l)(function(e,n){if((0,c.lp)(e)||(0,c.oT)(e)){const t=Object.keys(e.getFields());return(0,h.D)(n,t)}return[]}(t,i))),e.reportError(new o.__(`Cannot query field "${i}" on type "${t.name}".`+a,{nodes:n}))}}}},function(e){const n=Object.create(null);return{OperationDefinition:()=>!1,FragmentDefinition(t){const r=t.name.value;return n[r]?e.reportError(new o.__(`There can be only one fragment named "${r}".`,{nodes:[n[r],t.name]})):n[r]=t.name,!1}}},V,M,function(e){return{InlineFragment(n){const t=e.getType(),r=e.getParentType();if((0,c.Gv)(t)&&(0,c.Gv)(r)&&!(0,Z.zR)(e.getSchema(),t,r)){const i=(0,N.X)(r),a=(0,N.X)(t);e.reportError(new o.__(`Fragment cannot be spread here as objects of type "${i}" can never be of type "${a}".`,{nodes:n}))}},FragmentSpread(n){const t=n.name.value,r=function(e,n){const t=e.getFragment(n);if(t){const n=(0,U._)(e.getSchema(),t.typeCondition);if((0,c.Gv)(n))return n}}(e,t),i=e.getParentType();if(r&&i&&!(0,Z.zR)(e.getSchema(),r,i)){const a=(0,N.X)(i),s=(0,N.X)(r);e.reportError(new o.__(`Fragment "${t}" cannot be spread here as objects of type "${a}" can never be of type "${s}".`,{nodes:n}))}}}},function(e){const n=Object.create(null),t=[],r=Object.create(null);return{OperationDefinition:()=>!1,FragmentDefinition:e=>(i(e),!1)};function i(a){if(n[a.name.value])return;const s=a.name.value;n[s]=!0;const c=e.getFragmentSpreads(a.selectionSet);if(0!==c.length){r[s]=t.length;for(const n of c){const a=n.name.value,s=r[a];if(t.push(n),void 0===s){const n=e.getFragment(a);n&&i(n)}else{const n=t.slice(s),r=n.slice(0,-1).map((e=>'"'+e.name.value+'"')).join(", ");e.reportError(new o.__(`Cannot spread fragment "${a}" within itself`+(""!==r?` via ${r}.`:"."),{nodes:n}))}t.pop()}r[s]=void 0}}},function(e){return{OperationDefinition(n){var t;const r=P(null!==(t=n.variableDefinitions)&&void 0!==t?t:[],(e=>e.variable.name.value));for(const[n,t]of r)t.length>1&&e.reportError(new o.__(`There can be only one variable named "$${n}".`,{nodes:t.map((e=>e.variable.name))}))}}},function(e){let n=Object.create(null);return{OperationDefinition:{enter(){n=Object.create(null)},leave(t){const r=e.getRecursiveVariableUsages(t);for(const{node:i}of r){const r=i.name.value;!0!==n[r]&&e.reportError(new o.__(t.name?`Variable "$${r}" is not defined by operation "${t.name.value}".`:`Variable "$${r}" is not defined.`,{nodes:[i,t]}))}}},VariableDefinition(e){n[e.variable.name.value]=!0}}},function(e){let n=[];return{OperationDefinition:{enter(){n=[]},leave(t){const r=Object.create(null),i=e.getRecursiveVariableUsages(t);for(const{node:e}of i)r[e.name.value]=!0;for(const i of n){const n=i.variable.name.value;!0!==r[n]&&e.reportError(new o.__(t.name?`Variable "$${n}" is never used in operation "${t.name.value}".`:`Variable "$${n}" is never used.`,{nodes:i}))}}},VariableDefinition(e){n.push(e)}}},D,F,function(e){return{...x(e),Argument(n){const t=e.getArgument(),r=e.getFieldDef(),i=e.getParentType();if(!t&&r&&i){const t=n.name.value,a=r.args.map((e=>e.name)),s=(0,h.D)(t,a);e.reportError(new o.__(`Unknown argument "${t}" on field "${i.name}.${r.name}".`+(0,p.l)(s),{nodes:n}))}}}},A,function(e){return{ListValue(n){const t=(0,c.tf)(e.getParentInputType());if(!(0,c.HG)(t))return ce(e,n),!1},ObjectValue(n){const t=(0,c.xC)(e.getInputType());if(!(0,c.hL)(t))return ce(e,n),!1;const r=(0,ee.P)(n.fields,(e=>e.name.value));for(const i of Object.values(t.getFields()))if(!r[i.name]&&(0,c.Wd)(i)){const r=(0,N.X)(i.type);e.reportError(new o.__(`Field "${t.name}.${i.name}" of required type "${r}" was not provided.`,{nodes:n}))}},ObjectField(n){const t=(0,c.xC)(e.getParentInputType());if(!e.getInputType()&&(0,c.hL)(t)){const r=(0,h.D)(n.name.value,Object.keys(t.getFields()));e.reportError(new o.__(`Field "${n.name.value}" is not defined by type "${t.name}".`+(0,p.l)(r),{nodes:n}))}},NullValue(n){const t=e.getInputType();(0,c.zM)(t)&&e.reportError(new o.__(`Expected value of type "${(0,N.X)(t)}", found ${(0,j.S)(n)}.`,{nodes:n}))},EnumValue:n=>ce(e,n),IntValue:n=>ce(e,n),FloatValue:n=>ce(e,n),StringValue:n=>ce(e,n),BooleanValue:n=>ce(e,n)}},function(e){return{...ne(e),Field:{leave(n){var t;const r=e.getFieldDef();if(!r)return!1;const i=new Set(null===(t=n.arguments)||void 0===t?void 0:t.map((e=>e.name.value)));for(const t of r.args)if(!i.has(t.name)&&(0,c.dK)(t)){const i=(0,N.X)(t.type);e.reportError(new o.__(`Field "${r.name}" argument "${t.name}" of type "${i}" is required, but it was not provided.`,{nodes:n}))}}}}},function(e){let n=Object.create(null);return{OperationDefinition:{enter(){n=Object.create(null)},leave(t){const r=e.getRecursiveVariableUsages(t);for(const{node:t,type:i,defaultValue:a}of r){const r=t.name.value,s=n[r];if(s&&i){const n=e.getSchema(),c=(0,U._)(n,s.type);if(c&&!ue(n,c,s.defaultValue,i,a)){const n=(0,N.X)(c),a=(0,N.X)(i);e.reportError(new o.__(`Variable "$${r}" of type "${n}" used in position expecting type "${a}".`,{nodes:[s,t]}))}}}}},VariableDefinition(e){n[e.variable.name.value]=e}}},function(e){const n=new K,t=new Map;return{SelectionSet(r){const i=function(e,n,t,r,o){const i=[],[a,s]=Q(e,n,r,o);if(function(e,n,t,r,o){for(const[i,a]of Object.entries(o))if(a.length>1)for(let o=0;o<a.length;o++)for(let s=o+1;s<a.length;s++){const c=J(e,t,r,!1,i,a[o],a[s]);c&&n.push(c)}}(e,i,n,t,a),0!==s.length)for(let r=0;r<s.length;r++){Y(e,i,n,t,!1,a,s[r]);for(let o=r+1;o<s.length;o++)B(e,i,n,t,!1,s[r],s[o])}return i}(e,t,n,e.getParentType(),r);for(const[[n,t],r,a]of i){const i=L(t);e.reportError(new o.__(`Fields "${n}" conflict because ${i}. Use different aliases on the fields to fetch both if this was intentional.`,{nodes:r.concat(a)}))}}}},C]);Object.freeze([i,a,s,u,l,function(e){return{DirectiveDefinition(e){var n;const r=null!==(n=e.arguments)&&void 0!==n?n:[];return t(`@${e.name.value}`,r)},InterfaceTypeDefinition:n,InterfaceTypeExtension:n,ObjectTypeDefinition:n,ObjectTypeExtension:n};function n(e){var n;const r=e.name.value,o=null!==(n=e.fields)&&void 0!==n?n:[];for(const e of o){var i;t(`${r}.${e.name.value}`,null!==(i=e.arguments)&&void 0!==i?i:[])}return!1}function t(n,t){const r=P(t,(e=>e.name.value));for(const[t,i]of r)i.length>1&&e.reportError(new o.__(`Argument "${n}(${t}:)" can only be defined once.`,{nodes:i.map((e=>e.name))}));return!1}},d,g,D,F,$,x,A,C,ne]);var fe=t(34317),de=t(43165),pe=t(96374),he=t(95335);class Ee{constructor(e,n){this._ast=e,this._fragments=void 0,this._fragmentSpreads=new Map,this._recursivelyReferencedFragments=new Map,this._onError=n}get[Symbol.toStringTag](){return"ASTValidationContext"}reportError(e){this._onError(e)}getDocument(){return this._ast}getFragment(e){let n;if(this._fragments)n=this._fragments;else{n=Object.create(null);for(const e of this.getDocument().definitions)e.kind===E.h.FRAGMENT_DEFINITION&&(n[e.name.value]=e);this._fragments=n}return n[e]}getFragmentSpreads(e){let n=this._fragmentSpreads.get(e);if(!n){n=[];const t=[e];let r;for(;r=t.pop();)for(const e of r.selections)e.kind===E.h.FRAGMENT_SPREAD?n.push(e):e.selectionSet&&t.push(e.selectionSet);this._fragmentSpreads.set(e,n)}return n}getRecursivelyReferencedFragments(e){let n=this._recursivelyReferencedFragments.get(e);if(!n){n=[];const t=Object.create(null),r=[e.selectionSet];let o;for(;o=r.pop();)for(const e of this.getFragmentSpreads(o)){const o=e.name.value;if(!0!==t[o]){t[o]=!0;const e=this.getFragment(o);e&&(n.push(e),r.push(e.selectionSet))}}this._recursivelyReferencedFragments.set(e,n)}return n}}class _e extends(null){constructor(e,n,t){super(e,t),this._schema=n}get[Symbol.toStringTag](){return"SDLValidationContext"}getSchema(){return this._schema}}class me extends Ee{constructor(e,n,t,r){super(n,r),this._schema=e,this._typeInfo=t,this._variableUsages=new Map,this._recursiveVariableUsages=new Map}get[Symbol.toStringTag](){return"ValidationContext"}getSchema(){return this._schema}getVariableUsages(e){let n=this._variableUsages.get(e);if(!n){const t=[],r=new he.a(this._schema);(0,de.Vn)(e,(0,he.y)(r,{VariableDefinition:()=>!1,Variable(e){t.push({node:e,type:r.getInputType(),defaultValue:r.getDefaultValue()})}})),n=t,this._variableUsages.set(e,n)}return n}getRecursiveVariableUsages(e){let n=this._recursiveVariableUsages.get(e);if(!n){n=this.getVariableUsages(e);for(const t of this.getRecursivelyReferencedFragments(e))n=n.concat(this.getVariableUsages(t));this._recursiveVariableUsages.set(e,n)}return n}getType(){return this._typeInfo.getType()}getParentType(){return this._typeInfo.getParentType()}getInputType(){return this._typeInfo.getInputType()}getParentInputType(){return this._typeInfo.getParentInputType()}getFieldDef(){return this._typeInfo.getFieldDef()}getDirective(){return this._typeInfo.getDirective()}getArgument(){return this._typeInfo.getArgument()}getEnumValue(){return this._typeInfo.getEnumValue()}}function Te(e,n,t=le,r,i=new he.a(e)){var a;const s=null!==(a=null==r?void 0:r.maxErrors)&&void 0!==a?a:100;n||(0,fe.a)(!1,"Must provide document."),(0,pe.J)(e);const c=Object.freeze({}),u=[],l=new me(e,n,i,(e=>{if(u.length>=s)throw u.push(new o.__("Too many validation errors, error limit reached. Validation aborted.")),c;u.push(e)})),f=(0,de.j1)(t.map((e=>e(l))));try{(0,de.Vn)(n,(0,he.y)(i,f))}catch(e){if(e!==c)throw e}return u}var ve=t(89413);function ge(e){return{Field(n){const t=e.getFieldDef(),r=null==t?void 0:t.deprecationReason;if(t&&null!=r){const i=e.getParentType();null!=i||(0,y.k)(!1),e.reportError(new o.__(`The field ${i.name}.${t.name} is deprecated. ${r}`,{nodes:n}))}},Argument(n){const t=e.getArgument(),r=null==t?void 0:t.deprecationReason;if(t&&null!=r){const i=e.getDirective();if(null!=i)e.reportError(new o.__(`Directive "@${i.name}" argument "${t.name}" is deprecated. ${r}`,{nodes:n}));else{const i=e.getParentType(),a=e.getFieldDef();null!=i&&null!=a||(0,y.k)(!1),e.reportError(new o.__(`Field "${i.name}.${a.name}" argument "${t.name}" is deprecated. ${r}`,{nodes:n}))}}},ObjectField(n){const t=(0,c.xC)(e.getParentInputType());if((0,c.hL)(t)){const r=t.getFields()[n.name.value],i=null==r?void 0:r.deprecationReason;null!=i&&e.reportError(new o.__(`The input field ${t.name}.${r.name} is deprecated. ${i}`,{nodes:n}))}},EnumValue(n){const t=e.getEnumValue(),r=null==t?void 0:t.deprecationReason;if(t&&null!=r){const i=(0,c.xC)(e.getInputType());null!=i||(0,y.k)(!1),e.reportError(new o.__(`The enum value "${i.name}.${t.name}" is deprecated. ${r}`,{nodes:n}))}}}}var Ie=t(7829),Ne=t(17706),ye=(t(92906),t(27378),t(31542),Object.defineProperty),Oe=(e,n)=>ye(e,"name",{value:n,configurable:!0});const be=[i,a,s,u,l,d,g,D,F,$,A,C];function Se(e,n,t,r,o){const i=le.filter((e=>e!==M&&e!==k&&(!r||e!==V)));return t&&Array.prototype.push.apply(i,t),o&&Array.prototype.push.apply(i,be),Te(e,n,i).filter((e=>{if(-1!==e.message.indexOf("Unknown directive")&&e.nodes){const n=e.nodes[0];if(n&&n.kind===E.h.DIRECTIVE){const e=n.name.value;if("arguments"===e||"argumentDefinitions"===e)return!1}}return!0}))}Oe(Se,"validateWithCustomRules");const De={Error:1,Warning:2,Information:3,Hint:4},Fe=Oe(((e,n)=>{if(!e)throw new Error(n)}),"invariant");function $e(e,n=null,t,r,i){var a,s;let c=null;i&&(e+="string"==typeof i?"\n\n"+i:"\n\n"+i.reduce(((e,n)=>e+((0,j.S)(n)+"\n\n")),""));try{c=(0,ve.Qc)(e)}catch(n){if(n instanceof o.__){const t=Ce(null!==(s=null===(a=n.locations)||void 0===a?void 0:a[0])&&void 0!==s?s:{line:0,column:0},e);return[{severity:De.Error,message:n.message,source:"GraphQL: Syntax",range:t}]}throw n}return we(c,n,t,r)}function we(e,n=null,t,r){if(!n)return[];const o=Pe(Se(n,e,t,r),(e=>Ae(e,De.Error,"Validation"))),i=Pe(Te(n,e,[ge]),(e=>Ae(e,De.Warning,"Deprecation")));return o.concat(i)}function Pe(e,n){return Array.prototype.concat.apply([],e.map(n))}function Ae(e,n,t){if(!e.nodes)return[];const r=[];return e.nodes.forEach((o=>{const i="Variable"!==o.kind&&"name"in o&&void 0!==o.name?o.name:"variable"in o&&void 0!==o.variable?o.variable:o;if(i){Fe(e.locations,"GraphQL validation error requires locations.");const o=e.locations[0],a=ke(i),s=o.column+(a.end-a.start);r.push({source:`GraphQL: ${t}`,message:e.message,severity:n,range:new Ne.R(new Ne.P(o.line-1,o.column-1),new Ne.P(o.line-1,s))})}})),r}function Ce(e,n){const t=(0,Ie.o)(),r=t.startState(),o=n.split("\n");Fe(o.length>=e.line,"Query text must have more lines than where the error happened");let i=null;for(let n=0;n<e.line;n++)for(i=new Ne.C(o[n]);!i.eol()&&"invalidchar"!==t.token(i,r););Fe(i,"Expected Parser stream to be available.");const a=e.line-1,s=i.getStartOfToken(),c=i.getCurrentPosition();return new Ne.R(new Ne.P(a,s),new Ne.P(a,c))}function ke(e){const n=e.loc;return Fe(n,"Expected ASTNode to have a location."),n}Oe($e,"getDiagnostics"),Oe(we,"validateQuery"),Oe(Pe,"mapCat"),Oe(Ae,"annotations"),Oe(Ce,"getRange"),Oe(ke,"getLocation");const Re=["error","warning","information","hint"],je={"GraphQL: Validation":"validation","GraphQL: Deprecation":"deprecation","GraphQL: Syntax":"syntax"};r.C.registerHelper("lint","graphql",((e,n)=>$e(e,n.schema,n.validationRules,void 0,n.externalFragments).map((e=>({message:e.message,severity:e.severity?Re[e.severity-1]:Re[0],type:e.source?je[e.source]:void 0,from:r.C.Pos(e.range.start.line,e.range.start.character),to:r.C.Pos(e.range.end.line,e.range.end.character)})))))}}]);